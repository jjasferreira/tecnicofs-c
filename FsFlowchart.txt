FUNCTION 1 - tfs_init() -> state_init() + "create root inode" -> inode_create(T_DIRECTORY) (only time a directory is created)
                    state_init() sets everything to free  -> freeinode_ts -> free inodes
                                                            free_blocks -> free data blocks
                                                            free_open_file_entries -> free currently open files?
            inode_create(inode_type n_type) ->  iterates through inode_table. Upon finding the first free entry, 
                                                sets it as TAKEN. Sets new inode's type as n_type
                                                    for the root directory -> inumber b = data_block_alloc();
                                                    // Ex.1 here we have to make it so that there's 10 blocks plus a pointer to a block array
                                                                              inode.i_size = BLOCK_SIZE;
                                                                              inode.i_data_block = b;
                                                                              // creates a pointer dir entry containing the data in position b
                                                                              dir_entry_t *dir_entry = (dir_entry_t *)data_block_get(b);
                                                                              if dir_entry = NULL, set the inode as free in the inode table
                                                                              fills its block with empty entries, labeled with inumber == -1

FUNCTION 2 - tfs_destroy() -> state_destroy() -> does nothing lmao
             tfs_destroy_after_all_closed() já não é preciso implementar para o projeto.

FUNCTION 3 - tfs_lookup(*absolute path name*) -> looks for a file. Returns its inumber or -1 if unsuccessful
             tfs_lookup()-> checks if pathname is valid;
             find_in_dir(ROOT_DIR_INUM, name)

             find_in_dir() -> if inumber is invalid or points to a non directory entry, returns -1
                              data_block_get() -> locates the block which contains the directory entries
                              iterates over directory entries looking for one that has the target name, returning it if found, -1 otherwise

FUNCTION 4 - tfs_open(name, flags) -> flags: append mode, truncate file, create file if it does not exist
             tfs_open()  ->  checks if path name is valid
                            tfs_lookup(name)
                            if the file already exists:
                                inode_get();
                                //truncates if requested 
                                if inode's size is positive:
                                    frees inode and sets size to 0
                                if append is requested:
                                    changes offset to inode's size
                            else if creation is requested
                                inode_create();
                                add_dir_entry();
                            return add_to_open_file_table(inum, offset) (returns inumber - fhandle);

FUNCTION 5 - tfs_close(fhandle) -> return remove_from_open_file_table(fhandle)
            remove_from_open_file_table(fhandle) -> checks if the file handle is valid and that the current allocation state is TAKEN, then changes it to free

FUNCTION 6 - tfs_write(fhandle, void const* buffer /*content to write*/, size_t len /*length of the content*/) -> returns the number of bytes written
            tfs_write() -> file = get_open_file_entry(fhandle);
            inode_get();
            if contents don't fit, the number of bytes to write is equal to the block size minus the offset of the file;
            (TO BE CONTINUED...)
            